uint64_t batch_size = s_gridSize * s_blockSize;
for (; !exit; m_current_index++, m_current_nonce += batch_size)
{
	auto stream_index = m_current_index % s_numStreams;
	cudaStream_t stream = m_streams[stream_index];
	volatile uint32_t* buffer = m_search_buf[stream_index];
	uint64_t nonces[SEARCH_RESULT_BUFFER_SIZE - 1];
	uint64_t nonce_base = m_current_nonce - s_numStreams * batch_size;
	
	if (m_current_index >= s_numStreams)
	{
		CUDA_SAFE_CALL(cudaStreamSynchronize(stream));
		if (buffer[0] > 0)
		{
			nonces[0] = nonce_base + buffer[1];
			buffer[0] = 0;
			exit = hook.found(nonces, 1);
		}
		exit |= hook.searched(nonce_base, batch_size);
	}
	run_ethash_search(s_gridSize, s_blockSize, m_sharedBytes, stream, buffer, m_current_nonce, m_parallelHash);
}
